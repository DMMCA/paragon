// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/kcarretto/paragon/ent/credential"
	"github.com/kcarretto/paragon/ent/tag"
	"github.com/kcarretto/paragon/ent/target"
	"github.com/kcarretto/paragon/ent/task"
)

// TargetCreate is the builder for creating a Target entity.
type TargetCreate struct {
	config
	Name        *string
	OS          *target.OS
	PrimaryIP   *string
	MachineUUID *string
	PublicIP    *string
	PrimaryMAC  *string
	Hostname    *string
	LastSeen    *time.Time
	tasks       map[int]struct{}
	tags        map[int]struct{}
	credentials map[int]struct{}
}

// SetName sets the Name field.
func (tc *TargetCreate) SetName(s string) *TargetCreate {
	tc.Name = &s
	return tc
}

// SetOS sets the OS field.
func (tc *TargetCreate) SetOS(t target.OS) *TargetCreate {
	tc.OS = &t
	return tc
}

// SetPrimaryIP sets the PrimaryIP field.
func (tc *TargetCreate) SetPrimaryIP(s string) *TargetCreate {
	tc.PrimaryIP = &s
	return tc
}

// SetMachineUUID sets the MachineUUID field.
func (tc *TargetCreate) SetMachineUUID(s string) *TargetCreate {
	tc.MachineUUID = &s
	return tc
}

// SetNillableMachineUUID sets the MachineUUID field if the given value is not nil.
func (tc *TargetCreate) SetNillableMachineUUID(s *string) *TargetCreate {
	if s != nil {
		tc.SetMachineUUID(*s)
	}
	return tc
}

// SetPublicIP sets the PublicIP field.
func (tc *TargetCreate) SetPublicIP(s string) *TargetCreate {
	tc.PublicIP = &s
	return tc
}

// SetNillablePublicIP sets the PublicIP field if the given value is not nil.
func (tc *TargetCreate) SetNillablePublicIP(s *string) *TargetCreate {
	if s != nil {
		tc.SetPublicIP(*s)
	}
	return tc
}

// SetPrimaryMAC sets the PrimaryMAC field.
func (tc *TargetCreate) SetPrimaryMAC(s string) *TargetCreate {
	tc.PrimaryMAC = &s
	return tc
}

// SetNillablePrimaryMAC sets the PrimaryMAC field if the given value is not nil.
func (tc *TargetCreate) SetNillablePrimaryMAC(s *string) *TargetCreate {
	if s != nil {
		tc.SetPrimaryMAC(*s)
	}
	return tc
}

// SetHostname sets the Hostname field.
func (tc *TargetCreate) SetHostname(s string) *TargetCreate {
	tc.Hostname = &s
	return tc
}

// SetNillableHostname sets the Hostname field if the given value is not nil.
func (tc *TargetCreate) SetNillableHostname(s *string) *TargetCreate {
	if s != nil {
		tc.SetHostname(*s)
	}
	return tc
}

// SetLastSeen sets the LastSeen field.
func (tc *TargetCreate) SetLastSeen(t time.Time) *TargetCreate {
	tc.LastSeen = &t
	return tc
}

// SetNillableLastSeen sets the LastSeen field if the given value is not nil.
func (tc *TargetCreate) SetNillableLastSeen(t *time.Time) *TargetCreate {
	if t != nil {
		tc.SetLastSeen(*t)
	}
	return tc
}

// AddTaskIDs adds the tasks edge to Task by ids.
func (tc *TargetCreate) AddTaskIDs(ids ...int) *TargetCreate {
	if tc.tasks == nil {
		tc.tasks = make(map[int]struct{})
	}
	for i := range ids {
		tc.tasks[ids[i]] = struct{}{}
	}
	return tc
}

// AddTasks adds the tasks edges to Task.
func (tc *TargetCreate) AddTasks(t ...*Task) *TargetCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tc.AddTaskIDs(ids...)
}

// AddTagIDs adds the tags edge to Tag by ids.
func (tc *TargetCreate) AddTagIDs(ids ...int) *TargetCreate {
	if tc.tags == nil {
		tc.tags = make(map[int]struct{})
	}
	for i := range ids {
		tc.tags[ids[i]] = struct{}{}
	}
	return tc
}

// AddTags adds the tags edges to Tag.
func (tc *TargetCreate) AddTags(t ...*Tag) *TargetCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tc.AddTagIDs(ids...)
}

// AddCredentialIDs adds the credentials edge to Credential by ids.
func (tc *TargetCreate) AddCredentialIDs(ids ...int) *TargetCreate {
	if tc.credentials == nil {
		tc.credentials = make(map[int]struct{})
	}
	for i := range ids {
		tc.credentials[ids[i]] = struct{}{}
	}
	return tc
}

// AddCredentials adds the credentials edges to Credential.
func (tc *TargetCreate) AddCredentials(c ...*Credential) *TargetCreate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tc.AddCredentialIDs(ids...)
}

// Save creates the Target in the database.
func (tc *TargetCreate) Save(ctx context.Context) (*Target, error) {
	if tc.Name == nil {
		return nil, errors.New("ent: missing required field \"Name\"")
	}
	if err := target.NameValidator(*tc.Name); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"Name\": %v", err)
	}
	if tc.OS == nil {
		return nil, errors.New("ent: missing required field \"OS\"")
	}
	if err := target.OSValidator(*tc.OS); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"OS\": %v", err)
	}
	if tc.PrimaryIP == nil {
		return nil, errors.New("ent: missing required field \"PrimaryIP\"")
	}
	if tc.MachineUUID != nil {
		if err := target.MachineUUIDValidator(*tc.MachineUUID); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"MachineUUID\": %v", err)
		}
	}
	return tc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (tc *TargetCreate) SaveX(ctx context.Context) *Target {
	v, err := tc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (tc *TargetCreate) sqlSave(ctx context.Context) (*Target, error) {
	var (
		t     = &Target{config: tc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: target.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: target.FieldID,
			},
		}
	)
	if value := tc.Name; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: target.FieldName,
		})
		t.Name = *value
	}
	if value := tc.OS; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  *value,
			Column: target.FieldOS,
		})
		t.OS = *value
	}
	if value := tc.PrimaryIP; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: target.FieldPrimaryIP,
		})
		t.PrimaryIP = *value
	}
	if value := tc.MachineUUID; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: target.FieldMachineUUID,
		})
		t.MachineUUID = *value
	}
	if value := tc.PublicIP; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: target.FieldPublicIP,
		})
		t.PublicIP = *value
	}
	if value := tc.PrimaryMAC; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: target.FieldPrimaryMAC,
		})
		t.PrimaryMAC = *value
	}
	if value := tc.Hostname; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: target.FieldHostname,
		})
		t.Hostname = *value
	}
	if value := tc.LastSeen; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: target.FieldLastSeen,
		})
		t.LastSeen = *value
	}
	if nodes := tc.tasks; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   target.TasksTable,
			Columns: []string{target.TasksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: task.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.tags; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   target.TagsTable,
			Columns: target.TagsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tag.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.credentials; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   target.CredentialsTable,
			Columns: []string{target.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: credential.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if err := sqlgraph.CreateNode(ctx, tc.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	t.ID = int(id)
	return t, nil
}
